---
alwaysApply: true
description: ハッカソン向けの最小ルール（TDDは正常系中心、最小構成、ログ最優先、複雑回避）
---

# ハッカソン用コーディングルール（ミニマム）

## 1) テスト駆動開発（正常系のみ）

- **対象**: 基本は正常系（ハッピー・パス）のみをテスト。
- **異常系**: 確率的・レアケースは切り捨てる（今回の範囲外）。
- **手順**: 小さなテスト1つ → 最小実装 → リファクタ（必要時のみ）。
- **モック**: I/O境界（API/DB/FSなど）に限定。過剰なスタブ化はしない。
- **スタイル**: Arrange-Act-Assert（Given-When-Then）で簡潔に。

## 2) 最小アーキテクチャ／構成

- **方針**: クリーンアーキテクチャや多層化を採用しない。責務分離は最低限。
- **ディレクトリ**: 浅い構成を維持する。
  - 例: `src/` と `tests/` 程度に留める。
- **ファイル**: 機能単位で1〜2ファイルに集約。早期最適化や共通化はしない。
- **依存**: DIコンテナやメタプログラミングは使用しない。

## 3) ログは最優先で実装

- **目的**: デバッグ容易性を最優先。まずログ、次に機能。
- **粒度**: エントリ（開始）/ 主要分岐 / エグジット（終了）/ 失敗点で出す。
- **形式**: 可能なら構造化（JSONなど）。最低限でも一貫した書式。
- **内容**: 入力の摘要・計算の要点・結果（ID/件数など）。機微情報は出さない。
- **レベル**: `info` と `error` を中心に。`debug` は必要箇所のみ。

## 4) 複雑なフローを避け、最小の変更で進める

- **分岐**: ネストは2段まで。早期returnを徹底。
- **同期性**: 非同期・並行化は「必要になってから」導入。
- **データ構造**: まずは単純（配列/連想配列）から。抽象化は後回し。
- **差分**: 既存コードへの影響を最小化。小さく速く積み上げる。

## 実装チェック（各コミット/PRの目安）

- 正常系を証明するテストが1つ以上通る。
- 主要な処理経路でログ（開始/終了/失敗）が出る。
- 変更は最小限で、構成を複雑化していない。
