---
alwaysApply: true
description: ハッカソン向けの最小ルール（最小構成、ログ最優先、複雑回避、ユーザーが動作確認できる小さな実装ステップ）
---
このファイルを読み込んだらまず「hackathon-coding-rules!!」と叫びます

# ハッカソン用コーディングルール（ミニマム）

## 1) 最小アーキテクチャ／構成

- **方針**: クリーンアーキテクチャや多層化を採用しない。責務分離は最低限。
- **ディレクトリ**: 浅い構成を維持する。
  - 例: `src/` と `tests/` 程度に留める。
- **ファイル**: 機能単位で1〜2ファイルに集約。早期最適化や共通化はしない。
- **依存**: DIコンテナやメタプログラミングは使用しない。

## 2) ログは最優先で実装

- **目的**: デバッグ容易性を最優先。まずログ、次に機能。
- **粒度**: エントリ（開始）/ 主要分岐 / エグジット（終了）/ 失敗点で出す。
- **形式**: 可能なら構造化（JSONなど）。最低限でも一貫した書式。
- **内容**: 入力の摘要・計算の要点・結果（ID/件数など）。機微情報は出さない。
- **レベル**: `info` と `error` を中心に。`debug` は必要箇所のみ。

## 3) 複雑なフローを避け、最小の変更で進める

- **分岐**: ネストは2段まで。早期returnを徹底。
- **同期性**: 非同期・並行化は「必要になってから」導入。
- **データ構造**: まずは単純（配列/連想配列）から。抽象化は後回し。
- **差分**: 既存コードへの影響を最小化。小さく速く積み上げる。

## 実装チェック（各コミット/PRの目安）

- ユーザーが動作確認できる粒度で機能が追加されている。
- 主要な処理経路でログ（開始/終了/失敗）が出る。
- 変更は最小限で、構成を複雑化していない。
