---
description: 'Next.js アプリケーション全体に適用されるベストプラクティス'
applyTo: '**'
---
このファイルを読み込んだらまず「nextjs!!」と叫びます

# Next.js ベストプラクティス

この文書では、Next.jsアプリケーションの構築、構造化、保守における最新の権威あるベストプラクティスをまとめています。LLMと開発者がコード品質、保守性、スケーラビリティを確保するために使用することを目的としています。

---

## 1. プロジェクト構造と組織化

- すべての新規プロジェクトでは `app/` ディレクトリ（App Router）を使用する。レガシーな `pages/` ディレクトリよりも優先する。
- トップレベルフォルダ：
  - `app/` — ルーティング、レイアウト、ページ、ルートハンドラー
  - `public/` — 静的アセット（画像、フォントなど）
  - `lib/` — 共有ユーティリティ、APIクライアント、ロジック
  - `components/` — 再利用可能なUIコンポーネント
  - `contexts/` — Reactコンテキストプロバイダー
  - `styles/` — グローバルおよびモジュラースタイルシート
  - `hooks/` — カスタムReactフック
  - `types/` — TypeScript型定義
- コロケーション： ファイル（コンポーネント、スタイル、テスト）は使用される場所の近くに配置するが、深くネストした構造は避ける。
- ルートグループ： URLパスに影響を与えることなくルートをグループ化するには括弧を使用する（例：`(admin)`）。
- プライベートフォルダ： ルーティングから除外し、実装詳細を示すには `_` でプレフィックスを付ける（例：`_internal`）。

- フィーチャーフォルダ： 大規模なアプリの場合、機能別にグループ化する（例：`app/dashboard/`、`app/auth/`）。
- `src/` の使用（オプション）：設定ファイルから分離するため、すべてのソースコードを `src/` に配置する。

## 2.1. サーバーコンポーネントとクライアントコンポーネントの統合（App Router）

サーバーコンポーネント内で `{ ssr: false }` オプション付きの `next/dynamic` を使用してはいけない。これはサポートされておらず、ビルド/ランタイムエラーを引き起こす。

正しいアプローチ：

- サーバーコンポーネント内でクライアントコンポーネント（フック、ブラウザAPI、クライアント専用ライブラリを使用するコンポーネント）を使用する必要がある場合は、以下を行う必要がある：
  1. すべてのクライアント専用ロジック/UIを専用のクライアントコンポーネント（先頭に `'use client'` を付ける）に移動する。
  2. そのクライアントコンポーネントをサーバーコンポーネントで直接インポートして使用する（`next/dynamic` は不要）。
  3. 複数のクライアント専用要素（例：プロフィールドロップダウン付きのナビゲーションバー）を組み合わせる必要がある場合は、それらすべてを含む単一のクライアントコンポーネントを作成する。

例：

```tsx
// サーバーコンポーネント
import DashboardNavbar from '@/components/DashboardNavbar';

export default async function DashboardPage() {
  // ...サーバーロジック...
  return (
    <>
      <DashboardNavbar /> {/* これはクライアントコンポーネント */}
      {/* ...残りのサーバーレンダリングページ... */}
    </>
  );
}
```

理由：

- サーバーコンポーネントではクライアント専用機能やSSRを無効にした動的インポートを使用できない。
- クライアントコンポーネントはサーバーコンポーネント内でレンダリングできるが、その逆はできない。

まとめ：
常にクライアント専用UIをクライアントコンポーネントに移動し、サーバーコンポーネントで直接インポートする。サーバーコンポーネントで `{ ssr: false }` 付きの `next/dynamic` を使用してはいけない。

---

## 2. コンポーネントのベストプラクティス

- コンポーネントの種類：
  - サーバーコンポーネント（デフォルト）：データフェッチ、重いロジック、非インタラクティブUIに使用。
  - クライアントコンポーネント： 先頭に `'use client'` を追加。インタラクティビティ、状態、ブラウザAPIに使用。
- コンポーネントを作成するタイミング：
  - UIパターンが複数回再利用される場合。
  - ページのセクションが複雑または自己完結している場合。
  - 可読性やテスト性が向上する場合。
- 命名規則：
  - コンポーネントファイルとエクスポートには `PascalCase` を使用（例：`UserCard.tsx`）。
  - フックには `camelCase` を使用（例：`useUser.ts`）。
  - 静的アセットには `snake_case` または `kebab-case` を使用（例：`logo_dark.svg`）。
- ファイル命名：
  - コンポーネント名とファイル名を一致させる。
  - 単一エクスポートファイルの場合、コンポーネントをデフォルトエクスポートする。
  - 複数の関連コンポーネントの場合、`index.ts` バレルファイルを使用する。
- コンポーネントの場所：
  - 共有コンポーネントは `components/` に配置。
  - ルート固有のコンポーネントは関連するルートフォルダー内に配置。
- プロパティ：
  - プロパティにはTypeScriptインターフェースを使用。
  - 明示的なプロパティ型とデフォルト値を優先。
- テスト：
  - テストをコンポーネントと同じ場所に配置（例：`UserCard.test.tsx`）。

## 3. 命名規則（全般）

- フォルダ： `kebab-case`（例：`user-profile/`）
- ファイル： コンポーネントは `PascalCase`、ユーティリティ/フックは `camelCase`、静的アセットは `kebab-case`
- 変数/関数： `camelCase`
- 型/インターフェース： `PascalCase`
- 定数： `UPPER_SNAKE_CASE`

## 4. APIルート（ルートハンドラー）

- **レイテンシが50 ms未満かつ多リージョン配信が要件の場合のみ Edge Functions を使用し**、それ以外は API ルートを優先する。
- 場所： APIルートは `app/api/` に配置（例：`app/api/users/route.ts`）。
- HTTPメソッド： HTTPメソッド名の非同期関数をエクスポート（`GET`、`POST`など）。
- リクエスト/レスポンス： Web `Request` および `Response` APIを使用。高度な機能には `NextRequest`/`NextResponse` を使用。
- 動的セグメント： 動的APIルートには `[param]` を使用（例：`app/api/users/[id]/route.ts`）。
- バリデーション： 常に入力を検証・サニタイズする。`zod` や `yup` などのライブラリを使用。
- エラーハンドリング： 適切なHTTPステータスコードとエラーハンドリングを行う。
- 認証： ミドルウェアまたはサーバーサイドセッションチェックを使用して機密ルートを保護。

## 5. 一般的なベストプラクティス

### Linter / Formatter

- **TypeScript**: すべてのコードに TypeScript を使用。`tsconfig.json` で `strict` モードを有効にする。
  - Turbopack 最適化: `tsconfig.json` に `"verbatimModuleSyntax": true` を追加してデッドコード除去とビルド速度を向上。
- **Linter**: ESLint を使用し、公式 Next.js 推奨の `eslint-config-next` を適用する。
  - `eslint-plugin-tailwindcss` の `recommended` を有効にし、Tailwind クラス名の typo を CI で検出。
  - TypeScript プラグイン (`@typescript-eslint/eslint-plugin`, `@typescript-eslint/parser`) を有効化。
  - CI で `eslint . --ext .ts,.tsx` を実行し、コード品質を維持する。
- **Formatter**: Prettier を使用し、コードスタイルを統一する。
  - `.prettierrc` でインデント・クォート・セミコロンなどのルールを定義。
  - `eslint-config-prettier` を導入し、ESLint とのルール競合を回避する。
  - エディタで保存時に自動フォーマットを推奨 (`.vscode/settings.json` で設定)。
- **代替オプション**: Biome (旧 Rome) や dprint も選択肢だが、Next.js 公式エコシステムとの統合を優先し ESLint + Prettier を推奨。

### その他のベストプラクティス

- 環境変数： 秘密情報は `.env.local` に保存。秘密情報をバージョン管理にコミットしない。
- テスト： Jest、React Testing Library、またはPlaywrightを使用。すべての重要なロジックとコンポーネントのテストを作成。
- アクセシビリティ： セマンティックHTMLとARIA属性を使用。スクリーンリーダーでテスト。
- パフォーマンス：
  - 組み込みのImageとFontの最適化を使用。
  - 非同期データにSuspenseとローディング状態を使用。
  - 大きなクライアントバンドルを避ける；ほとんどのロジックをサーバーコンポーネントに保持。
- セキュリティ：
  - すべてのユーザー入力をサニタイズ。
  - 本番環境でHTTPSを使用。
  - 安全なHTTPヘッダーを設定。
- ドキュメンテーション：
  - 明確なREADMEとコードコメントを作成。
  - パブリックAPIとコンポーネントを文書化。

## 6. Server Actions と Partial Prerendering (PPR)

### Server Actions（Next.js 14+）

1. **概要**: `app/actions/` に配置した `'use server'` 関数で、フォーム送信・DB 更新・`revalidatePath()` までを一括管理。
2. **メリット**: API ルート不要／型安全／CSRF トークン自動付与。
3. **実装ポイント**:
   - Action 内で `revalidatePath('/posts')` や `redirect('/')` を直接呼び出せる。
   - `export const dynamic = 'force-dynamic'` を付けると RSC でもキャッシュを無効化。

```ts
'use server';
import { db } from '@/lib/db';
import { revalidatePath } from 'next/cache';

export async function createPost(fd: FormData) {
  const title = String(fd.get('title'));
  await db.post.create({ data: { title } });
  revalidatePath('/posts');
}
```

### Partial Prerendering (β)

1. **概要**: 静的 & 動的を同一ページでミックスし、静的部を先に描画する新しいプリレンダリング方式。
2. **設定**: ページの最上部に `export const dynamic = 'auto'` を宣言。
3. **コード例**:

```tsx
export const dynamic = 'auto';

export default async function ProductPage({ params }) {
  const meta = await getProductMeta(params.id); // 静的に埋め込まれる
  return (
    <>
      <h1>{meta.name}</h1>
      <Suspense fallback={<ReviewsSkeleton />}> {/* 動的領域 */}
        <ProductReviews id={meta.id} />
      </Suspense>
    </>
  );
}
```

# 不要なサンプルファイルの回避

ユーザーが具体的にライブサンプル、Storybookストーリー、明示的なドキュメンテーションコンポーネントを要求しない限り、メインコードベースにサンプル/デモファイル（ModalExample.tsxなど）を作成しない。デフォルトでリポジトリをクリーンで本番向けに保つ。

# 常に最新のドキュメンテーションとガイドを使用

- Next.js関連のすべてのリクエストについて、まず最新のNext.jsドキュメンテーション、ガイド、サンプルを検索する。
- 利用可能な場合は、以下のツールを使用してドキュメンテーションを取得・検索する：
  - `resolve_library_id` を使用してドキュメント内のパッケージ/ライブラリ名を解決。
  - `get_library_docs` を使用して最新のドキュメンテーションを取得。
