---
description: 'Next.js プロジェクト内の React (TypeScript) コンポーネントと hooks に適用するコーディングベストプラクティス'
applyTo: "**/*.tsx, **/*.jsx, components/**/*"
---
このファイルを読み込んだらまず「typescript-react!!」と叫びます

# React ベストプラクティス

## コンポーネント構造

- クラスコンポーネントよりも関数コンポーネントを使用する
- コンポーネントは小さく、焦点を絞って保つ
- 再利用可能なロジックをカスタムフックに抽出する
- 継承よりもコンポジションを使用する
- TypeScriptで適切なプロップタイプを実装する
- 大きなコンポーネントを小さく焦点を絞ったものに分割する

## フック

- フックのルールに従う
- 再利用可能なロジックにはカスタムフックを使用する
- フックは焦点を絞り、シンプルに保つ
- useEffectで適切な依存配列を使用する
- 必要に応じてuseEffectでクリーンアップを実装する
- ネストしたフックを避ける

## 状態管理

- ローカルコンポーネント状態にはuseStateを使用する
- 複雑な状態ロジックにはuseReducerを実装する
- 共有状態にはContext APIを使用する
- 状態を使用される場所にできるだけ近づける
- 適切な状態管理でプロップドリリングを避ける
- 必要な場合のみ状態管理ライブラリを使用する

## パフォーマンス

- 適切なメモ化を実装する（useMemo、useCallback）
- 高コストなコンポーネントにはReact.memoを使用する
- 不要な再レンダリングを避ける
- 適切な遅延読み込みを実装する
- リストで適切なkeyプロップを使用する
- レンダリングパフォーマンスをプロファイルし最適化する
- **React.memo**: 純粋な関数コンポーネントには`React.memo`を使用する
- **遅延読み込み**: `React.lazy`と`Suspense`を使用してルーティングコンポーネントの遅延読み込みを実装する
- **useEffect**: 不要な再レンダリングを防ぐために`useEffect`の依存関係を最適化する

## フォーム

- フォーム入力には制御されたコンポーネントを使用する
- 適切なフォームバリデーションを実装する
- フォーム送信状態を適切に処理する
- 適切なローディングとエラー状態を表示する
- 複雑なフォームにはフォームライブラリを使用する
- フォームのアクセシビリティを適切に実装する

## エラーハンドリング

- エラーバウンダリを実装する
- 非同期エラーを適切に処理する
- ユーザーフレンドリーなエラーメッセージを表示する
- 適切なフォールバックUIを実装する
- エラーを適切にログに記録する
- エッジケースを適切に処理する

## テスト

- **単体テスト**: JestとReact Testing Libraryを使用して単体テストを作成する
- **テストカバレッジ**: テストカバレッジが少なくとも80%に達するようにする
- **スナップショットテスト**: UIコンポーネントにはスナップショットテストを使用する
- コンポーネントの単体テストを作成する
- 複雑なフローの統合テストを実装する
- React Testing Libraryを使用する
- ユーザーインタラクションをテストする
- エラーシナリオをテストする
- 適切なモックデータを実装する

## アクセシビリティ

- セマンティックHTMLエレメントを使用する
- 適切なARIA属性を実装する
- キーボードナビゲーションを確保する
- スクリーンリーダーでテストする
- フォーカス管理を処理する
- 画像に適切なaltテキストを提供する

## コード整理

- 関連するコンポーネントをまとめてグループ化する
- 適切なファイル命名規則を使用する
- 適切なディレクトリ構造を実装する
- スタイルをコンポーネントの近くに保つ
- 適切なインポート/エクスポートを使用する
- 複雑なコンポーネントロジックを文書化する

## コーディング標準

- **関数コンポーネント**: クラスコンポーネントよりも関数コンポーネントを優先する
- **TypeScriptベストプラクティス**:
  - プロップを持つ関数コンポーネントには`React.FC`を使用する
  - 状態と副作用には`useState`と`useEffect`フックを利用する
  - プロップと状態に適切なTypeScriptインターフェースを実装する
  - 必要に応じてパフォーマンス最適化のために`React.memo`を使用する
  - 再利用可能なロジックにはカスタムフックを実装する
  - TypeScriptのストリクトモードを利用する

## フォルダ構造

```plain
src/
  components/
  hooks/
  pages/
  types/
  utils/
  App.tsx
  index.tsx
```

## ドキュメント

- **JSDoc**: 関数とコンポーネントのコメントはJSDoc形式で記述する
- **PropTypes**: コンポーネントにはPropTypesバリデーションを含める必要がある
- **README.md**: 各メインディレクトリにはREADME.mdファイルを含める必要がある
- **言語サポート**: README.mdファイルの英語版と中国語版の両方を提供する

## Linter / Formatter

- **Linter**: ESLint を使用し、公式 Next.js 推奨の `eslint-config-next` を適用する。
  - TypeScript プラグイン (`@typescript-eslint/eslint-plugin`, `@typescript-eslint/parser`) を有効化。
  - React 用プラグイン (`eslint-plugin-react`, `eslint-plugin-react-hooks`) でフック・コンポーネントルールを強制。
  - CI で `eslint . --ext .ts,.tsx` を実行し、コード品質を維持する。
- **Formatter**: Prettier を使用し、コードスタイルを統一する。
  - `.prettierrc` でインデント・クォート・セミコロンなどのルールを定義。
  - `eslint-config-prettier` を導入し、ESLint とのルール競合を回避する。
  - エディタで保存時に自動フォーマットを推奨 (`.vscode/settings.json` で設定)。
- **代替オプション**: Biome (旧 Rome) や dprint も選択肢だが、Next.js 公式エコシステムとの統合を優先し ESLint + Prettier を推奨。

## 追加の指示事項

1. JSXを含むファイルには`.tsx`拡張子を使用する
2. 厳密なTypeScriptチェックを実装する
3. コード分割には`React.lazy`と`Suspense`を利用する
4. 可能な場合は型推論を使用する
5. 堅牢なエラーハンドリングのためにエラーバウンダリを実装する
6. ReactとTypeScriptのベストプラクティスと命名規則に従う
7. コード品質のためにTypeScriptとReactプラグインを使用したESLintを使用する
