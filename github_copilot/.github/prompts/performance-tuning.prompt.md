---
mode: 'agent'
description: 'エージェントにパフォーマンス改善を依頼するプロンプトです。'
---

# パフォーマンス最適化指示

以下の方針と手法をもとに、機能（外部仕様）を変更せず既存テストをすべて通過した状態で、速度・スループット・メモリ効率・リソース消費の観点からコードを最適化してください。

## 最適化方針

- 外部仕様（API 仕様、入出力結果）は一切変更しない
- 既存のユニットテスト／結合テストは全件パス
- 最適化前後でベンチマークを取得し、改善効果を定量的に報告
- 可読性・保守性を著しく損なわない
- 変更のリスク・対策をコメントで明示

## 主な最適化手法

- ボトルネック特定：プロファイリング（CPU／メモリ／I/O）、Flame Graph等
- アルゴリズム改善：計算量削減（O(n²)→O(n log n)／O(n) など）
- データ構造見直し：適切なコレクション選択、プーリング、メモリプール
- I/O 最適化：バッファリング、ストリーミング、バッチ処理
- DB チューニング：クエリ最適化（EXPLAIN 解析）、インデックス追加
- キャッシュ導入：ローカル／分散キャッシュ（Redis・Memcached 等）
- 並列／非同期処理：スレッドプール、async/await、タスクキュー
- メモリ管理：オブジェクト再利用、ガベージコレクション設定チューニング
- ネットワーク最適化：接続プール、圧縮／遅延ロード、タイムアウト設定
- 静的リソース最適化：ミニファイ、圧縮、CDN 利用

## 具体的な改善例（必ず検討）

- プロファイラ結果に基づきホットスポットを優先して最適化
- 不要なループ内オブジェクト生成や重複計算を削減
- 重い I/O／外部呼び出しをバッチ化 or 非同期化
- DB クエリを EXPLAIN で分析し、インデックス追加 or クエリ自体の再設計
- 頻繁に参照されるデータをメモリキャッシュ化
- 並列処理・非同期I/Oでスループット向上
- GCを妨げる大きなオブジェクトの分割 or 再利用
- HTTP Keep-Alive／Connection Poolを適切に設定
- 外部API呼び出しにリトライ＋タイムアウトを導入
- JSON／XML／バイナリデータ転送時に圧縮やバッファリングを活用
- フロントエンドではコード分割（lazy load）やプリフェッチを導入
- コンテナ／クラウド設定（リソース割当、オートスケーリング）を最適化
