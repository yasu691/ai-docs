---
applyTo: 'src/main/**/*.java,src/test/**/*.java'
---


# Java開発マニュアル

バージョン：2.3 最終更新日：2023|06|23

## 目的

この文章では、Javaを使用してアプリケーション開発を実施する際に準拠すべき事項を、開発マニュアルとして説明する。

## マニュアル（Javaプログラム全般）

以下にJavaプログラム全般における開発標準、および禁止事項を記述する。

### コーディングを行う上での開発標準および禁止事項

#### 変数のスコープ

インスタンス変数は、特に理由がなければpublicにはしないこと。オブジェクト指向の基本的な性質である「カプセル化」を意識し、可能な限りprivateで宣言をすること。

クラス外から変数にアクセスする場合には、publicなアクセサメソッド（getterメソッド・setterメソッド）を使用してアクセスする。

##### 例：アクセサメソッドの例

```java
private int size; // privateなインスタンス変数
private boolean initialized // privateなインスタンス変数

// getterメソッド
public int getSize() {
  return size;
}

// setterメソッド
public void setSize(int newSize) {
  size = newSize;
}

// boolean変数に対するgetterメソッド
public Boolean isInitialized() {
  return initialized;
}
```

#### ハード・コーディングの回避

原則としてソースコード中には数値や文字列などを極力ハード・コーディングしないようにし、定数（public static final）として定義をする。

#### クラス変数とクラスメソッドの参照

クラス変数、クラスメソッドに対しては、特定のインスタンスを使ってアクセスするべきではない。クラス名を使うようにすること。

##### 例：クラスメソッドの参照

```java
Aclass anObject = new Aclass();
// AClassクラスのanObjectオブジェクト
Aclass.classMethod(); // OK
anObject.classMethod(); // 使うべきでない
```

#### 標準出力（System.in、System.out、System.err）の使用

Javaプログラム標準出力は使用しない。どうしてもデバッグ情報などの出力が必要である場合には、共通部品として提供させるログ出力クラスを使用して適切なログレベルで出力をすること。

#### パブリックなstatic変数

一部の共通機能を除いて、public static変数の使用を禁止する。

#### abstractクラスとinterfaceの使い分け

Javaでは多重継承が許されていないため、実装を伴わないスーパークラスはインターフェースとして定義するようにすること。

#### Synchronizedメソッド、Synchronizedブロック

一部の共通機能を除いてSynchronizedメソッド、Synchronizedブロックの使用を禁止する。

#### リフレクション

一部の共通機能を除いてリフレクションの使用を禁止する。

#### スレッド

一部の共通機能を除いてスレッドの使用を禁止する。

#### 文字列の結合

文字列（Stringクラス）の結合は、パフォーマンスを考慮してプラス演算子（+）を用いて行わないこと。文字列の結合には、StringBuilderクラスを使用すること。ただし、文字列の結合が少なく、StringBuilderを使用すると可読性が損なわれると思われる場合には、例外として文字列結合を許可する。

##### 例：文字列の結合（誤）

```java
String sql = "select 'a'";
sql = sql + " from dual";
sql = sql + " where (1 = 1)";
```

##### 例：文字列の結合（正）

```java
StringBuilder sql = new StringBuilder();
sql.append("select 'a'");
sql.append(" from dual");
sql.append(" where (1 = 1)");
```

##### 例：文字列の結合（例外）

```java
String a = "1";
String b = "2";
String c = "3";
int num = Integer.parseInt(a + b + c);
```

#### 中身のないfor文、while文

中身のないfor、while、do-while文は特別な場合を除いて原則禁止とする。

##### 例：中身のないfor文

```java
for(初期化; 条件; 更新);
```

##### 例：中身のないwhile文

```java
while(条件);
```

##### 例：中身のないdo-while文

```java
do {
;
} while (条件);
```

#### 拡張for構文

コレクションクラス、配列に対してのforループは、必ず拡張for構文を使用すること。

##### 例：拡張for構文

```java
for(変数名 : コレクション または 配列) {
文;
}
```

#### データの集合を扱う際の注意

データの集合を扱う際には配列よりもCollection、List、Set、またはMapインターフェースをimplementsしているクラスやRecordクラスなどを利用すること。配列では一部のJPAの機能がサポートされないので注意すること。

#### 総称型（Generics）の使用

コレクションクラスのインスタンス生成時には、実行時のClassCastExceptionを防止することと可読性を向上させるために、総称型を指定すること。

##### 例：総称型の使用例

```java
ArrayList<String> list = new ArrayList<String>();
```

#### 列挙型

処理の内部的な場合分けなどは列挙型を使用すること。列挙型は、switch文で容易に場合分けが可能である。

##### 例：列挙型のswitch文による場合分け

```java
enum MYDATA {A, B, C};
public static void main(String[] args) {
  MYDATA n = MYDATA.B;
  switch (n) {
    case A:
      System.out.println("arg is A");
      break;
    case B:
      System.out.println("arg is B");
      break;
    case C:
      System.out.println("arg is C");
      break;
    default:
      System.out.println("arg is default");
      break;
  }
}
```

#### 変数引数

同一クラス内において、メソッドシグネチャが引数の型が同じで引数の数が同じものについてはオーバーロードで実装をせずに、変数引数で実装すること。
SessionBeanのローカルインターフェースメソッドおよびリモートインターフェースメソッドはオーバーロードで実装する。

##### 例：メソッドオーバーロード

```java
public String printAll(String arg1) {
  return arg1;
}
public String printAll(String arg1, String arg2) {
  return arg1 + arg2;
}
public String printAll(String arg1, String arg2, String arg3) {
  return arg1 + arg2 + arg3;
}
... （同じように引数の数が違うメソッド）
```

##### 例：変数引数

```java
public String printAll(String... arg) {
  StringBuffer buf = new StringBuffer();
  for (String str : arg) {
    buf.append(str);
  }
  return buf.toString();
}
```

#### Java標準アノテーション

`@Deprecated`、`@Override`アノテーションについては記述を許可する（必須ではない）が、`@SuppressWarnings`、`@Target`、`@Retention`アノテーションについては使用を禁止する。

#### コンパイル・エラー、コンパイル警告

リリースするJavaファイルは、すべてのコンパイル・エラー、コンパイル警告が発生しない状態でリリースすること。

コンパイル警告例 ： インポート文曖昧、未使用インポート文、非推奨API使用など

### 可読性を向上させるためのマニュアル

#### メソッドの長さについて

1つのメソッドの実装コードが100行を超える場合、メソッドの分割を検討すること。

#### スーパークラスと同じ変数名を使わない

スーパークラスの変数名と同じ変数名を使うことを原則禁止する。もしも避けがたい意図がある場合には、必ずコメントを付加すること。

#### 可読性を意識したコメント

コメントを記述しなくても可読性が高いプログラム設計を意識すること。処理については詳細なコメントが必要な場合には、Javadoc記述部分に記述するなどの工夫をすること。

#### 名前の対称性

クラス名やメソッド名をつける場合には、以下の英語の対称性に気をつけること。

| 対称性    | 対応する英単語 |
| --------- | -------------- |
| add       | remove         |
| start     | stop           |
| first     | last           |
| up        | down           |
| open      | close          |
| lock      | unlock         |
| insert    | delete         |
| begin     | end            |
| get       | release        |
| show      | hide           |
| source    | destination    |
| old       | new            |
| get       | set            |
| send      | receive        |
| put       | get            |
| source    | target         |
| increment | decrement      |
| next      | previous       |

## マニュアル（Javaプログラム全般 例外処理）

以下にJavaプログラム全般における開発標準、および禁止事項のうち、例外処理に特化した部分を記述する。

### 例外処理

#### キャッチ禁止クラス

一般的な適切な対処方法は存在しないため、Throwableクラス、Exceptionクラス、RuntimeExceptionクラス、Errorクラスのキャッチは原則禁止とする。

特にクラスExceptionのキャッチは、開発中にコンパイル・エラーを回避するため実装されることがあるが、そのまま放置された場合に潜在的なシステム不良の原因となるため、以下の場合を除いて具体的なExceptionのサブクラスでキャッチをすること。

##### Exceptionのキャッチが認められる場合

開放を必要とする下記などについては、finallyブロックを実装するため、Exceptionクラスのキャッチをしてもよい。

* JDBCステートメントのクローズ
* 配列オブジェクトのnull設定
* コレクション・フレームワークのクローズ

また、自動生成したクラスのメソッドがExceptionクラスをスローしている場合、それらのメソッドをコールする際にはExceptionクラスのキャッチをしてもよい。

#### キャッチ句の注意点

キャッチ句の実装時は下記を注意すること。

##### キャッチ句を空実装にすることは禁止とする

これは、例外の隠蔽となるので、キャッチ句を実装するか、キャッチ句を排除すること。

##### 一切の処理をせずキャッチした例外をそのままスローすることは禁止とする

キャッチ句の実装を充実させるか、キャッチ句を排除すること。

意図的に別の例外クラスを生成し、キャッチした例外を内包することは正しい実装であり**重要**なことである。

例 ： SQLExceptionをキャッチして、特定エラー（ORA-XXXX）のみをAssertionErrorとしてスローするなど。

##### スタック・トレースの出力のみを実装することは禁止とする

最後までキャッチされなかった例外は、スタック・トレースを出力するため、キャッチ句の実装を充実させるか、キャッチ句を排除すること。

##### 通常処理中の例外の使用を禁止とする

例外クラスは最適化の対象から外されており、一般的に非常に処理が低速である。

例えば、「条件を満たさない場合に例外を返すメソッド」と「条件を満たさない場合にnullを返すメソッド」が存在する場合には、例外が発生しない後者のnullを返すメソッドを使用すること。

#### Throws宣言

メソッドのthrows宣言では、クラスExceptionなど広い範囲の例外クラスを対象とするthrows宣言は禁止とする。

throws宣言をする際には、実際に発生する例外クラスについてthrows宣言をすること。

## ファイルの構成

### Javaソースファイルの構成

1つのソースファイルには、1つのクラスまたはインターフェースを記述すること。ただし、privateクラス・インターフェースは、関連するクラスと同じソースファイルに記述すること。

また、コメントについては 6.コメント を参照。

ソースファイルは、以下のセクションにより構成される。

1. ソースファイル開始コメント
2. package宣言文
3. import宣言文
4. クラス・インターフェースのコード

#### package宣言文

package宣言文は、コメントを除いてソースファイルの先頭に記述すること。

package名には全て小文字のASCII文字を用いる。

#### import宣言文

importするクラスは以下の順に記述すること。

1. `java.*`
2. `javax.*`
3. その他の必要なクラス

#### クラス・インターフェースのコード

クラス・インターフェースのコードは、以下に示す順番で記述する。

##### クラス・インターフェースのドキュメンテーションコメント

クラス・インターフェースの情報をJavadocに準拠した形式で記述する。

##### クラス・インターフェース宣言

クラス・インターフェースの宣言を行う。

1つのソースファイル内に複数クラスがある場合には、publicクラスの宣言を一番先にする。（publicクラスは常に1つのみしか宣言できない）

##### クラス・インターフェースの実装に関するコメント

ドキュメンテーションコメントには適さないような、実装に関するコメントが必要であれば記述する。

##### クラス変数（static変数）・定数（static final）

public、protected、パッケージレベル（アクセス識別子なし）、privateの順に記述する。

##### インスタンス変数

public、protected、パッケージレベル（アクセス識別子なし）、privateの順に記述する。

##### コンストラクタ

デフォルトコンストラクタ（引数なし）を先頭に、引数の少ないものから順に記述する。

##### クラスメソッド（staticメソッド）

同じ名前のメソッド（オーバーロード）に関しては、引数の少ないものから順に記述する。

### インデントの単位

半角4個分のスペースをインデントの単位として使用する。

### 行の長さとインデント

1行の長さはなるべく半角80文字以内に収めるようにする。

80文字を超える場合、もしくは可読性を考慮した際には、以下の規則に則り改行する。

* イコールの後で改行
* カンマの後で改行
* 演算子の後で改行
* より高いレベルの記述での改行を優先する
* 2つ目以上のインデントでは、前の行と同じ位置に左端をそろえる。

##### 例：メソッド呼び出しの分割例

```java
someMethod(longExpression1, longExpression2, longExpression3,
            longExpression4, longExpression5);
            // メソッドの引数開始位置までインデント
```

##### 例：数式の分割例

```java
longName1 = longName2 * (longName3 + longName4 – longName5)
              + 4 \* longName6;
              // 演算開始位置までインデント
```

##### 例：if文の分割例

```java
if((condition1 && condition2) ||
    (condition3 && condition4) ||
    !(condition5 && condition6)) {
    // 4文字インデント**
    doSomethingAboutIt(); // 処理は4文字インデント
}
```

### 構造

1つの行には1つの文だけを記述すること。（複数の処理を1行には記述しない）

return文では、特別な理由がない限り"()"をつけない。（特別な理由とは、条件式を使用した場合などに、その値を明確化する必要がある場合など）

### 制御文（if文、for文、while文など）での構造

たとえ必要のない状況（実行行が1行しかない場合）であっても、必ず"{}"を記述する。

キーワード（if、for、whileなど）と、"("の間には半角1個分のスペースを記述する。

"{"は、キーワードと同じ行に記述する。また、"{"の前には半角1個分のスペースを記述する。

#### if-else文

##### 例：if文の構造

```java
if (条件) {
  文;
} else if (条件) {
  文;
} else {
  文;
}
```

#### for文

ループカウンタは、for()の中で初期化する。

##### 例： for文の構造

```java
for (初期化; 条件; 更新) {
  文;
}
```

#### while文

##### 例： while文の構造

```java
while (条件) {
  文;
}
```

#### do-while文

##### 例： do-while文の構造

```java
do {
  文;
} while (条件);
```

#### switch文

必要がない場合でもdefaultのcaseを記述する。また、defaultに対するbreakも記述する。

breakのないcaseでは、`/* breakなし */`とコメントを書き、処理を明確にする。

caseは、switchから空白4個分（タブ）インデントをする。

##### 例： switch文の構造

```java
switch (条件) {
  case ABC:
    文;
    /* breakなし */
  case DEF:
    文;
    break;
  default:
    文;
    break;
}
```

#### try-catch文

##### 例： try-catch文の構造

```java
try {
  文;
} catch (ExceptionClass e) {
  文;
} finally { // finallyが必要な場合
  文;
}
```

### 空白行

ソースコードの可読性を向上させるために、以下の規則に則り空白行を適宜追加すること。

#### 1行の空白行

以下の場所では、最低1行以上の空白行を挿入する。

* 各メソッド間の区切り
* メソッド内のローカル変数と最初の文との間の区切り
* その他、可読性を高めるために必要と思われる場所
* ソースファイル内の各セクション間の区切り
* クラス定義とインターフェース定義の間の区切り

#### 空白スペース

空白スペースは、以下の状況において使用する。

* "("が次に来るようなキーワードの後ろ（ただし、メソッド名に続く"("の場合にはスペースを開けない）
* メソッドの引数を区別するコンマ","の後ろ
* 二項演算子とオペランドの間 （ただし、"++"や"--"に関してはスペースを開けない）
* for文の中の式の";"の後ろ

##### 例： 空白スペース

```java
while (true) { // while文
  someMethod(param, size); // メソッドの引数
  a = b + c; // 二項演算子
  if (a == c) { // if文
    d++; // ++にはつけない
  }
}
for (int i = 0; i < size; i++) { // for文
  文;
}
```

#### 変数の宣言

1つの行に1つの宣言を記述すること。（配列と変数を1行に記述しない）

ただし、Java10で追加されたローカル変数の型推論(var宣言)は禁止する。

コードの可読性低下（変数の型がわかりにくくなる）,プログラムの理解が難しくなる懸念があるため。

― 例 ―

・通常の宣言の場合

`ByteArrayOutputStream outputStream = new ByteArrayOutputStream();`

・型推論(var)を利用した宣言の場合

`var outputStream = new ByteArrayOutputStream();`

#### 配列の宣言

配列の宣言は、「Type[] arrayName」とする。（Type arrayName[]とは記述しない）

##### 例： 変数の宣言

```java
/* 悪い例 */
int level, size; // やってはいけない
Object foo, fooArray[]; // 絶対にいけない
Object someArray[]; // []は型の後ろに記述する
/* 良い例 */
int level; // 1行に1つの宣言
int size;
Object foo;
Object[] fooArray; // 配列の宣言
Object[] someArray;
```

#### ローカル変数の宣言

ローカル変数を宣言する場所は、基本的にブロック"{・・・}"の先頭とする。

ただし、forループのループカウンタは例外として"for (・・・)"の中で宣言をすること。

また、変数のスコープが短い一時的な変数の場合には、変数を使用する場所で宣言してもよい。（可読性を損なわないように注意すること）

ローカル変数は、宣言されている場所で初期化するようにする。ただし、その変数の初期値が何らかの計算の後で決まる場合はその限りではない。

#### クラス・インターフェース・メソッドの宣言

メソッド名と"("の間にスペースは入れない。

宣言文の後にくる"{"の前には1個分の半角スペースを入れること。

"}"は、それに対応する文と同じインデントレベルにインデントする。

各メソッドは空行で区切ること。

##### 例： クラス・インターフェース・メソッドの宣言

```java
class Sample extends Object {
  int ivar1;
  int ivar2;
  Sample(int i, int j) { // "{"は同じ行
    ivar1 = i;
    ivar2 = j;
  } // "}"は対応する宣言と同じインデント
  // メソッド同士の間は空行で区切る
  int emptyMethod() { // 空でも"{"は同じ行
  } // 空でも"}"は対応する宣言と同じインデント
}
```

## コメント

### コメントの種類

Javaのコメントには以下の2種類がある。

| 種類                         | 説明                                                          | 形式        | 利用場面                                                               |
| ---------------------------- | ------------------------------------------------------------- | ----------- | ---------------------------------------------------------------------- |
| ドキュメンテーションコメント | JavadocによってHTML形式のドキュメントに出力するためのコメント | `/** ~~ */` | interface、class、method、fieldの直前にドキュメント化したい内容を記述  |
| 実装コメント                 | コードを読む手助けのためのコメント                            | `/* ~~ */`  | デバッグ時など、一時的にコードを無効化する際に使用                     |
| 実装コメント                 | コードを読む手助けのためのコメント                            | `// ~~`     | メソッド内にて、ビジネスロジック、コードの概要、一時変数の定義等を記述 |

### ドキュメンテーションコメント

Javadocによってドキュメントに出力するコメントを、以下の項目に対して付加する。

1. クラス・インターフェース
2. クラス変数・定数
3. メソッド

#### クラス・インターフェースに対するドキュメンテーションコメントのフォーマット

##### 例：クラスに対するドキュメンテーションコメント

```java
/**
 *<pre>
 * ...クラスの仕様説明...
 *
 * 修正履歴
 * 日付       Ver. 担当者    修正内容
 * ---------- ---- --------- ---------------------
 * YYYY-MM-DD 9.9  XXXX      XXXX
 *</pre>
 *
 * @author 著者名（複数可）
 * @version 9.9
 */
```

最低でもクラス仕様の説明、著者名、バージョンは記述する。

クラスの仕様説明の部分は、Javadocを生成したときに出力されるので、できるだけ丁寧に詳しく書くようにすること。簡単な使用例があれば、記述しておくと他の人が再利用しやすくなる。

#### メソッドに対するドキュメンテーションコメントのフォーマット

##### 例：メソッドに対するドキュメンテーションコメント

```java
/**
 *<pre>
 * ...メソッドの仕様説明...
 *</pre>
 *
 * @param 引数名 説明（引数、引数の説明。複数可）
 * @return 説明（リターン値の説明）
 * @exception フルクラス名 説明（例外のクラス名、説明）
 * @see クラス名、メソッド名、定義名など（重要な関連がある場合。例：親クラスが抽象クラスである など）
 */
```

最低でも、メソッドの仕様説明、引数名、返り値の説明、Exceptionの説明は記述する。

メソッドの仕様説明の部分は、Javadocを生成したときに出力されるので、できるだけ丁寧に詳しく書くようにすること。簡単な使用例があれば、記述しておくと他の人が再利用しやすくなる。

#### HTML形式のコメント

ドキュメンテーションコメントは、JavadocツールによってHTMLに変換される。したがって、コメントをHTML形式で記述することで、任意に整形されたコメントを作成することができる。

##### 例：HTML形式のコメント

```java
/**
 * A class representing a <b>window</b> on the screen.
 * For example:
 * <pre>
 * Window win = new Window(parent);
 * win.show();
 * </pre>
 class Window extends BaseWindow {
 ...
 }
 */
```

#### Javadocのタグ

あらかじめ決められた種類の情報（著者名など）を「@」で始まるタグで記述することができる。

同じ種類のタグを複数書くこともできるが、連続した行に書かなければならない。

### 実装コメント

#### ブロックコメント（`/* ~~ */`）

複数行にわたるコメントアウトに利用する。特定のコードを無効化するが、後に復帰の可能性があるので残しておくためにコメント化する時や、デバッグ時に一時的に無効化するときに使用し、原則としてコード説明自体には利用しない。

対象コードとは同じインデントにする。

#### 1行コメント（`// ~~`）

ビジネスロジック、コードの概要、一時変数の定義等を記述する際に利用する。対象コードの1行前に、説明対象と同じインデントで記述する。原則として複数行にわたる場合でも当該コメント形式をとる。したがって、多数行にならないようなるべく簡潔に記述すること。

#### 行末コメント（`~~ //`）

対象コードの後ろに短く記述する。

##### 例：ブロックコメント

```java
/* 複数行にわたるコメントアウトとして記述する。
  if (xxxx) {
    doSomething(); || 行末コメント
  } else {
    return false; || 行末コメント
  }
*/
```

##### 例：1行コメント

```java
// 1行コメント
someMethod();
// データ構造、アルゴリズムなど
// ドキュメンテーションコメント以外の説明をするための
// 複数行にわたるコメントはこのように記述する。
```

##### 例：行末コメント

```java
if(xxxx) {
  doSomething() // 行末コメント
} else {
  return false; // 行末コメント
}
```
